# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.33
#
# Don't modify this file, modify the SWIG interface instead.

package InCharge::FlowWrapper;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package InCharge::FlowWrapperc;
bootstrap InCharge::FlowWrapper;
package InCharge::FlowWrapper;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package InCharge::FlowWrapper;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package InCharge::FlowWrapper;


############# Class : InCharge::FlowWrapper::FlowAPI ##############

package InCharge::FlowWrapper::FlowAPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( InCharge::FlowWrapper );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = InCharge::FlowWrapperc::new_FlowAPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        InCharge::FlowWrapperc::delete_FlowAPI($self);
        delete $OWNER{$self};
    }
}

*flowConnectToServerNoNegotiate = *InCharge::FlowWrapperc::FlowAPI_flowConnectToServerNoNegotiate;
*flowConnectToServer = *InCharge::FlowWrapperc::FlowAPI_flowConnectToServer;
*flowRead = *InCharge::FlowWrapperc::FlowAPI_flowRead;
*flowWrite = *InCharge::FlowWrapperc::FlowAPI_flowWrite;
*flowForceClose = *InCharge::FlowWrapperc::FlowAPI_flowForceClose;
*flowReadableNow = *InCharge::FlowWrapperc::FlowAPI_flowReadableNow;
*flowCanRead = *InCharge::FlowWrapperc::FlowAPI_flowCanRead;
*flowCanWrite = *InCharge::FlowWrapperc::FlowAPI_flowCanWrite;
*flowIsComplete = *InCharge::FlowWrapperc::FlowAPI_flowIsComplete;
*flowGetBufsize = *InCharge::FlowWrapperc::FlowAPI_flowGetBufsize;
*flowDumpAllFlows = *InCharge::FlowWrapperc::FlowAPI_flowDumpAllFlows;
*flowFlush = *InCharge::FlowWrapperc::FlowAPI_flowFlush;
*flowReadline = *InCharge::FlowWrapperc::FlowAPI_flowReadline;
*flowGetChar = *InCharge::FlowWrapperc::FlowAPI_flowGetChar;
*flowReadBypass = *InCharge::FlowWrapperc::FlowAPI_flowReadBypass;
*flowFillRead = *InCharge::FlowWrapperc::FlowAPI_flowFillRead;
*flowMinUnget = *InCharge::FlowWrapperc::FlowAPI_flowMinUnget;
*flowClearInputBuffer = *InCharge::FlowWrapperc::FlowAPI_flowClearInputBuffer;
*flowClearOutputBuffer = *InCharge::FlowWrapperc::FlowAPI_flowClearOutputBuffer;
*flowGetDescriptor = *InCharge::FlowWrapperc::FlowAPI_flowGetDescriptor;
*flowPhysGetPhysicalHandle = *InCharge::FlowWrapperc::FlowAPI_flowPhysGetPhysicalHandle;
*flowPhysOpen = *InCharge::FlowWrapperc::FlowAPI_flowPhysOpen;
*flowPhysIsOpen = *InCharge::FlowWrapperc::FlowAPI_flowPhysIsOpen;
*flowPhysClose = *InCharge::FlowWrapperc::FlowAPI_flowPhysClose;
*flowPhysGetDeadman = *InCharge::FlowWrapperc::FlowAPI_flowPhysGetDeadman;
*flowPhysSelectRead = *InCharge::FlowWrapperc::FlowAPI_flowPhysSelectRead;
*flowPhysSelectWrite = *InCharge::FlowWrapperc::FlowAPI_flowPhysSelectWrite;
*flowPhysDoOpen = *InCharge::FlowWrapperc::FlowAPI_flowPhysDoOpen;
*flowPhysDoClose = *InCharge::FlowWrapperc::FlowAPI_flowPhysDoClose;
*flowPhysDoSelect = *InCharge::FlowWrapperc::FlowAPI_flowPhysDoSelect;
*flowPhysSetTimeLimit = *InCharge::FlowWrapperc::FlowAPI_flowPhysSetTimeLimit;
*flowPhysGetTimeLimit = *InCharge::FlowWrapperc::FlowAPI_flowPhysGetTimeLimit;
*flowPhysReadableNowWithTimer = *InCharge::FlowWrapperc::FlowAPI_flowPhysReadableNowWithTimer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package InCharge::FlowWrapper;

*RET_PARAM_NOK = *InCharge::FlowWrapperc::RET_PARAM_NOK;
*RET_NOK = *InCharge::FlowWrapperc::RET_NOK;
*RET_OK = *InCharge::FlowWrapperc::RET_OK;
1;

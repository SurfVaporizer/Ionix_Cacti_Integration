.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SMPP 3"
.TH SMPP 3 "2011-06-02" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::SMPP \- pure Perl implementation of SMPP 3.4 over TCP
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Net::SMPP;
\&  $smpp = Net::SMPP->new_transceiver($host, port=>$port,
\&                        system_id => 'yourusername',
\&                        password  => 'secret',
\&                        ) or die;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Implements Short Message Peer to Peer protocol, which is frequently used to
pass short messages between mobile operators implementing short message
service (\s-1SMS\s0). This is applicable to both european \s-1GSM\s0 and american \s-1CDMA/TDMA\s0
systems.
.PP
This documentation is not intended to be complete reference to \s-1SMPP\s0
protocol \- use the \s-1SMPP\s0 specification documents (see references
section) to obtain exact operation and parameter names and their
meaning. You may also need to obtain site specific documentation about
the remote end and any protocol extensions that it supports or demands
before you start a project. This document follows the convention of
spelling parameter names exactly as they appear in the \s-1SMPP\s0 v3.4
documentation. \s-1SMPP\s0 v4.0 support also follows the respective
documentation, except where v4.0 usage is in conflict with v3.4 usage,
in which case the latter prevails (in practise I believe no such
conflicts remain in the madule at present). For a complete list of error
code and optional parameter enumerations, the reader is encouraged to
consult the source code or \s-1SMPP\s0 speciofications.
.PP
Despite its name, \s-1SMPP\s0 protocol defines a client (\s-1ESME\s0) and a server
(often called \s-1SMSC\s0 in the mobile operator world). Client usually
initiates the \s-1TCP\s0 connection and does \fIbind\fR to log in. After
binding, a series of request response pairs, called PDUs (protocol
data units) is exchanged. Request can be initiated by either end
(hence \*(L"peer\-to\-peer\*(R"?) and the other end reponds. Requests are
numbered with a sequence number and each response has corresponding
sequence number. This allows several requests to be pending at the
same time. Conceptually this is similar to \s-1IMAP\s0 or \s-1LDAP\s0 message IDs.
Usually the \f(CW$smpp\fR object maintains the sequence numbers by itself and
the programmer need not concern himself with their exact values, but
should a need to override them arise, the seq argument can be supplied
to any request or response method.
.PP
Normally this module operates in synchronous mode, meaning that a
method that sends a request will also block until it gets the
corresponding response. Internal command used for waiting for response is
.PP
.Vb 1
\&    $resp_pdu = $smpp->wait_pdu($cmd_id, $seq);
.Ve
.PP
If, while waiting for a particular response, other PDUs are received
they are either handled by handlers (set up by constructor) or
discarded. Both command code and sequence number must match. Typically
a handler for enquire command is set up while all other commands are
silently dropped. This practise may not be very suitable for
transceiver mode of operation and certainly is not suitable for
implementing a \s-1SMSC\s0.
.PP
Synchronous operation makes it impossible to interleave \s-1SMPP\s0
operations, thus it should be regarded as a simplified programming
model for simple tasks. Anyone requiring more advanced control has to
use the asynchronous mode and take up the burden of understanding and
implementing more of the message flow logic in his own application.
.PP
In synchronous mode request \s-1PDU\s0 methods return a Net::SMPP::PDU object
representing the response, if all went well protocolwise, or undef if
there was a protocol level error. If undef was returned, the reason
for the failure can be extracted from ${*$smpp}{smpperror} and
${*$smpp}{smpperrorcode} (actual codes are undocumented at the moment,
but are guaranteed not to change) variables and the global variable
$!. These variables are meaningless if anything else than undef was
returned. The response itself may be an error response if there was an
application level error in the remote end. In this case the application
level error can be determined from \f(CW$pdu\fR\->{status} field. Some
responses also have optional parameters that further clarify the failure,
see documentation for each operation.
.PP
If a protocol level error happens, probably the only safe action is
to destroy the connection object (e.g. undef \f(CW$smpp\fR). If an application
level error happens, then depending on how the remote end has been
implemented it may be possible to continue operation.
.PP
Module can also be used asynchronously by specifying async=>1 to the
constructor. In this mode command methods return immediately with the
sequence number of the \s-1PDU\s0 and user should poll for any responses
using
.PP
.Vb 1
\&    $pdu = $smpp->wait_pdu($cmd_id, $seq);
.Ve
.PP
Typically \fIwait_pdu()\fR is used to wait for a response, but if \fIwait_pdu()\fR
is used to wait for a command, the caller should generate appropriate
response.
.PP
If caller wants to receive next available \s-1PDU\s0, he can call
.PP
.Vb 1
\&    $pdu = $smpp->read_pdu();
.Ve
.PP
which will block until a \s-1PDU\s0 is received from the stream. The caller would
then have to check if the \s-1PDU\s0 is a response or a request and take appropriate
action. The smsc.pl example program supplied with this distribution
demonstrates a possible framework for handling both requests and responses.
.PP
If the caller does not want to block on \fIwait_pdu()\fR or \fIread_pdu()\fR, he
must use \fIselect()\fR to determine if the socket is readable (*** what if
\&\s-1SSL\s0 layer gets inserted?). Even if the socket selects for reading,
there may not be enough data to complete the \s-1PDU\s0, so the call may
still block. Currently there is no reliable mechanism for avoiding
this. If this bothers you, you may consider allocating a separate
process for each connection so that blocking does not matter, or you
may set up some sort of timeout (see \fIperlipc\fR\|(1) man page) or you may
rewrite this module and contribute patches.
.PP
Response methods always return the sequence number, irrespective
of synchronous or asynchronous mode, or undef if an error happened.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Do not call. Has special internal meaning during accepting connections
from listening socket.
.IP "\fInew_connect()\fR" 4
.IX Item "new_connect()"
Create a new \s-1SMPP\s0 client object and open conncetion to \s-1SMSC\s0 host
.Sp
.Vb 9
\&    $smpp = Net::SMPP->new_connect($host,
\&       system_id => 'username',   # usually needed (default '')
\&       password => 'secret',      # usually needed (default '')
\&       system_type => '',         # default ok, often not needed
\&       interface_version => 0x34, # default ok, almost never needed
\&       addr_ton => 0x00,          # default ok, type of number unknwn
\&       addr_npi => 0x00,          # default ok, number plan indicator
\&       address_range => '',       # default ok, regex matching nmbrs
\&       ) or die;
.Ve
.Sp
Usually this constructor is not called directly. Use
\&\fInew_transceiver()\fR, \fInew_transmitter()\fR, and \fInew_receiver()\fR instead.
.IP "\fInew_transceiver()\fR" 4
.IX Item "new_transceiver()"
.PD 0
.IP "\fInew_transmitter()\fR" 4
.IX Item "new_transmitter()"
.IP "\fInew_receiver()\fR" 4
.IX Item "new_receiver()"
.PD
These constructors first construct the object using \fInew_connect()\fR and
then bind using given type of bind request. See bind family of
methods, below. These constructors are usually used to implement
\&\s-1ESME\s0 type functionality.
.IP "new_listen('localhost', port=>2251)" 4
.IX Item "new_listen('localhost', port=>2251)"
Create new \s-1SMPP\s0 server object and open socket to listen on
given port. This constructor is usually used to implement a \s-1SMSC\s0.
.SH "REQUEST PDU METHODS"
.IX Header "REQUEST PDU METHODS"
Each request \s-1PDU\s0 method constructs a \s-1PDU\s0 from list of arguments supplied
and sends it to the wire.
.PP
If async mode has been enabled (by specifying \*(L"async=>1\*(R" in the constructor
or as an argument to the method), the methods return sequence number of
the \s-1PDU\s0 just sent. This number can be later used to match up the response,
like this:
.PP
.Vb 6
\&    $seq = $smpp->query_sm(message_id => $msg_id) or die;
\&    ...
\&    $resp_pdu = $smpp->wait_pdu(Net::SMPP::CMD_query_sm_resp, $seq)
\&       or die;
\&    die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.PP
If async mode is not enabled (i.e. \*(L"async=>1\*(R" was not specified
neither in constructor nor the method), the method will wait for the
corresponding response and return Net::SMPP::PDU object representing
that response. The application should check the outcome of the
operation from the status field of the response \s-1PDU\s0, like this:
.PP
.Vb 3
\&    $resp_pdu = $smpp->query_sm(message_id => $msg_id) or die;
\&    die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.PP
All request \s-1PDU\s0 methods optionally take \*(L"seq=>123\*(R" argument that
allows explicit specification of the sequence number. The default is
to increment internally stored sequence number by one and use that.
.PP
Most PDUs have mandatory parameters and optional parameters. If
mandatory parameter is not supplied, it is inherited from the smpp
object. This means that the parameter can either be set as an argument
to the constructor or it is inherited from built-in defaults in the
innards of Net::SMPP (see \f(CW\*(C`Default\*(C'\fR table from line 217
onwards). Some mandatory parameters can not be defaulted \- if they are
missing a die results. In descriptions below, defaultable mandatory
parameters are show with the default value and comment indicating that
its defaultable.
.PP
Optional parameters can be supplied to all PDUs (although the \s-1SMPP\s0
spec does not allow optional parameters for some PDUs, the module does
not check for this) by listing them in the order that they should be
appended to the end of the \s-1PDU\s0. Optional parameters can not be
defaulted \- if the parameter is not supplied, it simply is not
included in the \s-1PDU\s0. Optional parameters are not supported
by previous versions of the \s-1SMPP\s0 protocol (up to and including 3.3).
Applications wishing to be downwards compatible should not make
use of optional parameters.
.PP
Standard optional parameters can be supplied by their name (see
\&\f(CW\*(C`param_tab\*(C'\fR in the Net::SMPP source code, around line 345, for list of
known optional parameters), but the programmer still needs to supply
the value of the parameter in the expected format (one often has to
use pack to construct the value). Consult \s-1SMPP\s0 specifications for
the correct format.
.PP
It is possible to supply arbitrary unsupported optional parameters
by simply supplying the parameter tag as a decimal number. Consult
your site dependent documentation to figure out the correct tags and
to determine the correct format for the value.
.PP
When optional parameters are returned in response PDUs, they are
decoded and made available under both numeric tag and symbolic tag, if
known. For example the delivery_failure_reson of data_sm_resp can be
accessed both as \f(CW$resp\fR\->{delivery_failure_reson} and \f(CW$resp\fR\->{1061}.
The application needs to interpret the formatting of optional
parameters itself. The module always assumes they are strings, while
often they actually are interpretted as integers. Consult \s-1SMPP\s0
specifications and site dependent documentation for correct format and
use unpack to obtain the numbers.
.PP
If an unknown nonnumeric parameter tags are supplied a warning is
issued and parameter is skipped.
.PP
In general the Net::SMPP module does not enforce \s-1SMPP\s0
specifications. This means that it will happily accept too long or too
short values for manatory or optional parameters. Also the internal
formatting of the parameter values is not checked in any way. The
programmer should consult the \s-1SMPP\s0 specifications to learn the correct
length and format of each mandatory and optional parameter.
.PP
Similarily, if the remote end returns incorrect PDUs and Net::SMPP is
able to parse them (usually because length fields match), then Net::SMPP
will not perform any further checks. This means that some fields
may be longer than allowed for in the specifications.
.PP
I opted to leave the checks out at this stage because I needed a flexible
module that allowed me to explore even nonconformant \s-1SMSC\s0 implementations.
If the lack of sanity checks bothers you, formulate such checks and
submit me a patch. Ideally one could at construction time supply an
argument like \*(L"strict=>1\*(R" to enable the sanity checks.
.IP "\fIalert_notification()\fR (4.12.1, p.108)" 4
.IX Item "alert_notification() (4.12.1, p.108)"
Sent by \s-1SMSC\s0 to \s-1ESME\s0 when particular mobile subscriber has become
available. source_addr specifies which mobile subscriber. esme_addr
specifies which esme the message is destined to. Alert notifications
can arise if delivery pending flag had been set
for the subscriber from previous data_sm operation.
.Sp
There is no response \s-1PDU\s0.
.Sp
.Vb 8
\&    $smpp->alert_notification(
\&                              source_addr_ton => 0x00, # default ok
\&                              source_addr_npi => 0x00, # default ok
\&                              source_addr => '',       # default ok
\&                              esme_addr_ton => 0x00,   # default ok
\&                              esme_addr_npi => 0x00,   # default ok
\&                              esme_addr => $esme_addr, # mandatory
\&                              ) or die;
.Ve
.IP "\fIbind_transceiver()\fR (4.1.5, p.51)" 4
.IX Item "bind_transceiver() (4.1.5, p.51)"
.PD 0
.IP "\fIbind_transmitter()\fR (4.1.1, p.46)" 4
.IX Item "bind_transmitter() (4.1.1, p.46)"
.IP "\fIbind_receiver()\fR (4.1.3, p.48)" 4
.IX Item "bind_receiver() (4.1.3, p.48)"
.PD
Bind family of methods is used to authenticate the client (\s-1ESME\s0) to
the server (\s-1SMSC\s0). Usually bind happens as part of corresponding
constructor \f(CW\*(C`new_transceiver()\*(C'\fR, \f(CW\*(C`new_transmitter()\*(C'\fR, or
\&\f(CW\*(C`new_receiver()\*(C'\fR so these methods are rarely called directly. These
methods take a plethora of options, which are largely the same as the
options taken by the constructors and can safely be defaulted.
.Sp
.Vb 9
\&    $smpp->bind_transceiver(
\&       system_id => 'username',   # usually needed (default '')
\&       password => 'secret',      # usually needed (default '')
\&       system_type => '',         # default ok, often not needed
\&       interface_version => 0x34, # default ok, almost never needed
\&       addr_ton => 0x00,          # default ok, type of number unkwn
\&       addr_npi => 0x00,          # default ok, number plan indic.
\&       address_range => '',       # default ok, regex matching tels
\&       ) or die;
.Ve
.Sp
Typically it would be called like:
.Sp
.Vb 4
\&    $resp_pdu = $smpp->bind_transceiver(system_id => 'username',
\&                                        password => 'secret') or die;
\&    die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.Sp
or to inform \s-1SMSC\s0 that you can handle all Spanish numbers:
.Sp
.Vb 6
\&    $resp_pdu = $smpp->bind_transceiver(system_id => 'username',
\&                                        password => 'secret',
\&                                        address_range => '^\e+?34')
\&       or die;
\&    die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.IP "\fIcancel_sm()\fR (4.9.1, p.98)" 4
.IX Item "cancel_sm() (4.9.1, p.98)"
Issued by \s-1ESME\s0 to cancel one or more short messages. Two principal
modes of operation are:
.Sp
1. if message_id is supplied, other fields can be left at
defaults. This mode deletes just one message.
.Sp
2. if message_id is not supplied (or is empty string), then
the other fields must be supplied and all messages matching
the criteria reflected by the other fields are deleted.
.Sp
.Vb 10
\&    $smpp->cancel_sm(
\&                     service_type => '',      # default ok
\&                     message_id => '', # default ok, but often given
\&                     source_addr_ton => 0x00, # default ok
\&                     source_addr_npi => 0x00, # default ok
\&                     source_addr => '',       # default ok
\&                     dest_addr_ton => 0x00,   # default ok
\&                     dest_addr_npi => 0x00,   # default ok
\&                     destination_addr => '',  # default ok
\&                   ) or die;
.Ve
.Sp
For example
.Sp
.Vb 6
\&   $resp_pdu = $smpp->submit_sm(destination_addr => '+447799658372',
\&                                 short_message => 'test message')
\&      or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
\&   $msg_id = $resp_pdu->{message_id};
.Ve
.Sp
.Vb 4
\&   $resp_pdu = $smpp->query_sm(message_id => $msg_id) or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
\&   print "Message state is $resp_pdu->{message_state}\en";
.Ve
.Sp
.Vb 5
\&   $resp_pdu = $smpp->replace_sm(message_id => $msg_id,
\&                                 short_message => 'another test')
\&      or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.Sp
.Vb 3
\&   $resp_pdu = $smpp->cancel_sm(message_id => $msg_id) or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.IP "\fIdata_sm()\fR (4.7.1, p.87)" 4
.IX Item "data_sm() (4.7.1, p.87)"
Newer alternative to submit_sm and deliver_sm. In addition to that
data_sm can be used to pass special messages such as \s-1SMSC\s0 Delivery
Receipt, \s-1SME\s0 Delivery Acknowledgement, \s-1SME\s0 Manual/User
Acknowledgement, Intermediate notification.
.Sp
Unlike submit_sm and deliver_sm, the short_message parameter is not
mandatory. Never\-the\-less, the optional parameter message_payload must
be supplied for things to work correctly.
.Sp
.Vb 13
\&    $smpp->data_sm(
\&                   service_type => '',      # default ok
\&                   source_addr_ton => 0x00, # default ok
\&                   source_addr_npi => 0x00, # default ok
\&                   source_addr => '',       # default ok
\&                   dest_addr_ton => 0x00,   # default ok
\&                   dest_addr_npi => 0x00,   # default ok
\&                   destination_addr => $tel,  # mandatory
\&                   esm_class => 0x00,       # default ok
\&                   registered_delivery => 0x00, #default ok
\&                   data_coding => 0x00,     # default ok
\&                   message_payload => 'test msg', # opt, but needed
\&                   ) or die;
.Ve
.Sp
For example
.Sp
.Vb 5
\&   $resp_pdu = $smpp->data_sm(destination_addr => '+447799658372',
\&                              message_payload => 'test message')
\&      or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.IP "\fIdeliver_sm()\fR (4.6.1, p.79)" 4
.IX Item "deliver_sm() (4.6.1, p.79)"
Issued by \s-1SMSC\s0 to send message to an \s-1ESME\s0. Further more \s-1SMSC\s0
can transfer following special messages: 1. \s-1SMSC\s0 delivery receipt,
2. \s-1SME\s0 delivery acknowledgement, 3. \s-1SME\s0 Manual/User Acknowledgement,
4. Intermediate notification. These messages are sent in response
to \s-1SMS\s0 message whose registered_delivery parameter requested them.
.Sp
If message data is longer than 254 bytes, the optional parameter
\&\f(CW\*(C`message_payload\*(C'\fR should be used to store the message and
\&\f(CW\*(C`short_message\*(C'\fR should be set to empty string. N.B. although protocol
has mechanism for sending fairly large messages, the underlying mobile
network usually does not support very large messages. \s-1GSM\s0 supports
only up to 160 characters, other systems 128 or even just 100 characters.
.Sp
.Vb 21
\&    $smpp->deliver_sm(
\&                   service_type => '',      # default ok
\&                   source_addr_ton => 0x00, # default ok
\&                   source_addr_npi => 0x00, # default ok
\&                   source_addr => '',       # default ok
\&                   dest_addr_ton => 0x00,   # default ok
\&                   dest_addr_npi => 0x00,   # default ok
\&                   destination_addr => $t,  # mandatory
\&                   esm_class => 0x00,       # default ok
\&                   protocol_id => 0x00,     # default ok on CDMA,TDMA
\&                                            #   on GSM value needed
\&                   priority_flag => 0x00,   # default ok
\&                   schedule_delivery_time => '', # default ok
\&                   validity_period => '',        # default ok
\&                   registered_delivery => 0x00,  # default ok
\&                   replace_if_present_flag => 0x00, # default ok
\&                   data_coding => 0x00,     # default ok
\&                   sm_default_msg_id => 0x00,    # default ok
\&                   short_message => '',     # default ok, but
\&                                            #   usually supplied
\&                   ) or die;
.Ve
.Sp
For example
.Sp
.Vb 5
\&   $resp_pdu = $smpp->deliver_sm(destination_addr => '+447799658372',
\&                                 short_message => 'test message')
\&      or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.IP "\fIenquire_link()\fR (4.11.1, p.106)" 4
.IX Item "enquire_link() (4.11.1, p.106)"
Used by either \s-1ESME\s0 or \s-1SMSC\s0 to \*(L"ping\*(R" the other side. Takes no
parameters.
.Sp
.Vb 1
\&    $smpp->enquire_link() or die;
.Ve
.IP "\fIoutbind()\fR (4.1.7, p.54, 2.2.1, p.16)" 4
.IX Item "outbind() (4.1.7, p.54, 2.2.1, p.16)"
Used by \s-1SMSC\s0 to signal \s-1ESME\s0 to originate a \f(CW\*(C`bind_receiver\*(C'\fR request to
the \s-1SMSC\s0. \f(CW\*(C`system_id\*(C'\fR and \f(CW\*(C`password\*(C'\fR authenticate the \s-1SMSC\s0 to the
\&\s-1ESME\s0.  The \f(CW\*(C`outbind\*(C'\fR is used when \s-1SMSC\s0 initiates the \s-1TCP\s0 session and
needs to trigger \s-1ESME\s0 to perform a \f(CW\*(C`bind_receiver\*(C'\fR. It is not needed
if the \s-1ESME\s0 initiates the \s-1TCP\s0 connection (e.g. sec 2.7.1, p.27).
.Sp
There is not response \s-1PDU\s0 for \f(CW\*(C`outbind\*(C'\fR, instead the \s-1ESME\s0 is
expected to issue \f(CW\*(C`bind_receiver\*(C'\fR.
.Sp
.Vb 4
\&    $smpp->outbind(
\&                   system_id => '',  # default ok, but usually given
\&                   password => '',   # default ok, but usually given
\&                   ) or die;
.Ve
.IP "\fIquery_sm()\fR (4.8.1, p.95)" 4
.IX Item "query_sm() (4.8.1, p.95)"
Used by \s-1ESME\s0 to query status of a submitted short message. Both
message_id and source_addr must match (if source_addr was defaulted to
\&\s-1NULL\s0 during submit, it must be \s-1NULL\s0 here, too). See example near
\&\f(CW\*(C`cancel_sm\*(C'\fR.
.Sp
.Vb 6
\&    $smpp->query_sm(
\&                   message_id => $msg_id,   # mandatory
\&                   source_addr_ton => 0x00, # default ok
\&                   source_addr_npi => 0x00, # default ok
\&                   source_addr => '',       # default ok
\&                   ) or die;
.Ve
.IP "\fIreplace_sm()\fR (4.10.1, p.102)" 4
.IX Item "replace_sm() (4.10.1, p.102)"
Used by \s-1ESME\s0 to replace a previously submitted short message, provided
it is still pending delivery. Both message_id and source_addr must
match (if source_addr was defaulted to \s-1NULL\s0 during submit, it must be
\&\s-1NULL\s0 here, too). See example near \f(CW\*(C`cancel_sm\*(C'\fR.
.Sp
.Vb 12
\&    $smpp->replace_sm(
\&                   message_id => $msg_id,   # mandatory
\&                   source_addr_ton => 0x00, # default ok
\&                   source_addr_npi => 0x00, # default ok
\&                   source_addr => '',       # default ok
\&                   schedule_delivery_time => '', # default ok
\&                   validity_period => '',        # default ok
\&                   registered_delivery => 0x00,  # default ok
\&                   sm_default_msg_id => 0x00,    # default ok
\&                   short_message => '',     # default ok, but
\&                                            #   usually supplied                   
\&                   ) or die;
.Ve
.IP "\fIsubmit_sm()\fR (4.4.1, p.59)" 4
.IX Item "submit_sm() (4.4.1, p.59)"
Used by \s-1ESME\s0 to submit short message to the \s-1SMSC\s0 for onward
transmission to the specified short message entity (\s-1SME\s0). The
submit_sm does not support the transaction message mode.
.Sp
If message data is longer than 254 bytes, the optional parameter
\&\f(CW\*(C`message_payload\*(C'\fR should be used to store the message and
\&\f(CW\*(C`short_message\*(C'\fR should be set to empty string. N.B. although protocol
has mechanism for sending fairly large messages, the underlying mobile
network usually does not support very large messages. \s-1GSM\s0 supports
only up to 160 characters.
.Sp
.Vb 21
\&    $smpp->submit_sm(
\&                   service_type => '',      # default ok
\&                   source_addr_ton => 0x00, # default ok
\&                   source_addr_npi => 0x00, # default ok
\&                   source_addr => '',       # default ok
\&                   dest_addr_ton => 0x00,   # default ok
\&                   dest_addr_npi => 0x00,   # default ok
\&                   destination_addr => $t,  # mandatory
\&                   esm_class => 0x00,       # default ok
\&                   protocol_id => 0x00,     # default ok on CDMA,TDMA
\&                                            #   on GSM value needed
\&                   priority_flag => 0x00,   # default ok
\&                   schedule_delivery_time => '', # default ok
\&                   validity_period => '',        # default ok
\&                   registered_delivery => 0x00,  # default ok
\&                   replace_if_present_flag => 0x00, # default ok
\&                   data_coding => 0x00,     # default ok
\&                   sm_default_msg_id => 0x00,    # default ok
\&                   short_message => '',     # default ok, but
\&                                            #   usually supplied
\&                   ) or die;
.Ve
.Sp
For example
.Sp
.Vb 5
\&   $resp_pdu = $smpp->submit_sm(destination_addr => '+447799658372',
\&                                 short_message => 'test message')
\&      or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.Sp
Or
.Sp
.Vb 5
\&   $resp_pdu = $smpp->submit_sm(destination_addr => '+447799658372',
\&                                short_message => '',
\&                                message_payload => 'a'x500) or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.IP "\fIsubmit_multi()\fR (4.5.1, p.69)" 4
.IX Item "submit_multi() (4.5.1, p.69)"
Used by \s-1ESME\s0 to submit short message to the \s-1SMSC\s0 for onward
transmission to the specified short message entities (SMEs). This
command is especially destined for multiple recepients.
.Sp
If message data is longer than 254 bytes, the optional parameter
\&\f(CW\*(C`message_payload\*(C'\fR should be used to store the message and
\&\f(CW\*(C`short_message\*(C'\fR should be set to empty string. N.B. although protocol
has mechanism for sending fairly large messages, the underlying mobile
network usually does not support very large messages. \s-1GSM\s0 supports
only up to 160 characters.
.Sp
.Vb 27
\&    $smpp->submit_multi(
\&                   service_type => '',      # default ok
\&                   source_addr_ton => 0x00, # default ok
\&                   source_addr_npi => 0x00, # default ok
\&                   source_addr => '',       # default ok
\&                   dest_flag =>             # default ok
\&                        [ MULTIDESTFLAG_SME_Address,
\&                          MULTIDESTFLAG_dist_list, ... ],
\&                   dest_addr_ton =>         # default ok
\&                        [ 0x00, 0x00, ... ],
\&                   dest_addr_npi =>         # default ok
\&                        [ 0x00, 0x00, ... ],
\&                   destination_addr =>      # mandatory
\&                        [ $t1, $t2, ... ],
\&                   esm_class => 0x00,       # default ok
\&                   protocol_id => 0x00,     # default ok on CDMA,TDMA
\&                                            #   on GSM value needed
\&                   priority_flag => 0x00,   # default ok
\&                   schedule_delivery_time => '', # default ok
\&                   validity_period => '',        # default ok
\&                   registered_delivery => 0x00,  # default ok
\&                   replace_if_present_flag => 0x00, # default ok
\&                   data_coding => 0x00,     # default ok
\&                   sm_default_msg_id => 0x00,    # default ok
\&                   short_message => '',     # default ok, but
\&                                            #   usually supplied
\&                   ) or die;
.Ve
.Sp
For example
.Sp
.Vb 6
\&   $resp_pdu = $smpp->submit_multi(destination_addr =>
\&                                   [ '+447799658372', '+447799658373' ],
\&                                   short_message => 'test message')
\&      or die;
\&   die "Response indicated error: " . $resp_pdu->explain_status()
\&       if $resp_pdu->status;
.Ve
.Sp
The destinations are specified as an array reference. dest_flag,
dest_addr_ton, and dest_addr_npi must have same cardinality as
destination_addr if they are present. Default for dest_flag
is MULTIDESTFLAG_SME_Address, i.e. normal phone number.
.IP "\fIunbind()\fR (4.2, p.56)" 4
.IX Item "unbind() (4.2, p.56)"
Used by \s-1ESME\s0 to unregisters \s-1ESME\s0 from \s-1SMSC\s0. Does not take any
parameters.
.Sp
.Vb 1
\&    $smpp->unbind() or die;
.Ve
.SH "RESPONSE PDU METHODS"
.IX Header "RESPONSE PDU METHODS"
Response \s-1PDU\s0 methods are used to indicate outcome of requested
commands. Typically these methods would be used by someone
implementing a server (\s-1SMSC\s0).
.PP
Response PDUs do not have separate asynchronous behaviour pattern.
.IP "\fIbind_receiver_resp()\fR" 4
.IX Item "bind_receiver_resp()"
.PD 0
.IP "\fIbind_transmitter_resp()\fR" 4
.IX Item "bind_transmitter_resp()"
.IP "\fIbind_transceiver_resp()\fR" 4
.IX Item "bind_transceiver_resp()"
.PD
.Vb 3
\&    $smpp->bind_transceiver_resp(
\&                                 system_id => '', # default ok
\&                                 ) or die;
.Ve
.IP "\fIcancel_sm_resp()\fR (4.9.2, p.100)" 4
.IX Item "cancel_sm_resp() (4.9.2, p.100)"
.Vb 1
\&    $smpp->cancel_sm_resp() or die;
.Ve
.IP "\fIdata_sm_resp()\fR" 4
.IX Item "data_sm_resp()"
.Vb 1
\&    $smpp->data_sm_resp(message_id => $msg_id) or die;
.Ve
.IP "\fIdeliver_sm_resp()\fR" 4
.IX Item "deliver_sm_resp()"
.Vb 1
\&    $smpp->deliver_sm_resp(message_id => $msg_id) or die;
.Ve
.IP "\fIenquire_link_resp()\fR (4.11.2, p.106)" 4
.IX Item "enquire_link_resp() (4.11.2, p.106)"
.Vb 1
\&    $smpp->enquire_link_resp() or die;
.Ve
.IP "\fIgeneric_nack()\fR (4.3.1, p.57)" 4
.IX Item "generic_nack() (4.3.1, p.57)"
.Vb 1
\&    $smpp->generic_nack() or die;
.Ve
.IP "\fIquery_sm_resp()\fR (4.6.2, p.96)" 4
.IX Item "query_sm_resp() (4.6.2, p.96)"
.Vb 6
\&    $smpp->query_sm_resp(
\&                         message_id => $msg_id,   # mandatory
\&                         final_date => '',        # default ok
\&                         message_state => $state, # mandatory
\&                         error_code => 0x00,      # default ok
\&                   ) or die;
.Ve
.IP "\fIreplace_sm_resp()\fR (4.10.2, p.104)" 4
.IX Item "replace_sm_resp() (4.10.2, p.104)"
.Vb 1
\&    $smpp->replace_sm_resp() or die;
.Ve
.IP "\fIsubmit_sm_resp()\fR (4.4.2, p.67)" 4
.IX Item "submit_sm_resp() (4.4.2, p.67)"
.Vb 1
\&    $smpp->submit_sm_resp(message_id => $msg_id) or die;
.Ve
.IP "\fIsubmit_multi_resp()\fR (4.5.2, p.76)" 4
.IX Item "submit_multi_resp() (4.5.2, p.76)"
.Vb 6
\&    $smpp->submit_multi_resp(message_id => $msg_id
\&                             dest_addr_ton => [], # default ok
\&                             dest_addr_npi => [], # default ok
\&                             destination_addr => [],  # mandatory
\&                             error_status_code => [], # mandatory
\&                             ) or die;
.Ve
.IP "\fIunbind_resp()\fR (4.2.2, p.56)" 4
.IX Item "unbind_resp() (4.2.2, p.56)"
.Vb 1
\&    $smpp->unbind_resp() or die;
.Ve
.SH "MESSAGE ENCODING AND LENGTH"
.IX Header "MESSAGE ENCODING AND LENGTH"
.RS 4
Many \s-1SMS\s0 technologies have inherent message length limits. For example
\&\s-1GSM\s0 specifies length to be 140 bytes. Using 7 bit encoding, this holds
the 160 characters that people are familiar with. Net::SMPP does not
enforce this limit in any way, i.e. if you create too long message,
then it is your problem. You should at application layer make sure
you stay within limits.
.Sp
Net::SMPP also does not automatically perform the encoding, not even
if you set data_encoding parameter. Application layer is responsible
for performing the encoding and setting the data_encoding parameter
accordingly.
.Sp
To assist in performing the usual 7 bit encoding, following functions
are provided (but you have to call them explicitly):
.IP "\fIpack_7bit()\fR" 4
.IX Item "pack_7bit()"
.PD 0
.IP "\fIunpack_7bit()\fR" 4
.IX Item "unpack_7bit()"
.PD
Example
.Sp
.Vb 4
\&   $resp_pdu = $smpp->submit_sm(destination_addr => '+447799658372',
\&                                data_encoding => 0x00,
\&                                short_message => pack_7bit('test message'))
\&      or die;
.Ve
.RE
.RS 4
.Sp
The rationale for leaving encoding and length issues at application
layer is two fold: 1. often the data is just copied through to another
message or protocol, thus we do not really care how it is encoded or
how long it is. Presumably it was valid at origin. 2. This policy
avoids underlying technology dependencies in the module. Often local
deployments have all the manner of hacks that make this area very
difficult to chart. So I leave it to local application developer to
find out what is locally needed.
.RE
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.IP "\fIread_pdu()\fR" 4
.IX Item "read_pdu()"
Reads a \s-1PDU\s0 from stream and analyzes it into Net::SMPP::PDU
object (if \s-1PDU\s0 is of known type). Blocks until \s-1PDU\s0 is available.
If you do not want it to block, do select on the socket to
make sure some data is available (unfortunately some data
may be available, but not enough, so it can still block).
.Sp
\&\fIread_pdu()\fR is very useful for implementing main loop of \s-1SMSC\s0
where unknown PDUs must be received in random order and
processed.
.Sp
.Vb 1
\&    $pdu = $smpp->read_pdu() or die;
.Ve
.IP "\fIwait_pdu()\fR" 4
.IX Item "wait_pdu()"
Reads PDUs from stream and handles or discards them until matching \s-1PDU\s0
is found. Blocks until success. Typically \fIwait_pdu()\fR is used
internally by request methods when operating in synchronous mode.  The
PDUs to handle are specified by \f(CW\*(C`${*$me}{handlers}\-\*(C'\fR{$command_id}>.
The handlers table is initially populated to handle enquire_link PDUs
automatically, but this can be altered using \f(CW\*(C`handlers\*(C'\fR argument to
constructor.
.Sp
.Vb 1
\&    $pdu = $smpp->wait_pdu($cmd_id_to_wait, $seq_to_wait) or die;
.Ve
.IP "set_version($vers)" 4
.IX Item "set_version($vers)"
Sets the protocol version of the object either to 0x40 or 0x34. Its
important to use this method instead of altering \f(CW$smpp\fR\->{smpp_version}
field directly because there are several other fields that have to be
set in tandem.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Typical client:
.PP
.Vb 5
\&  use Net::SMPP;
\&  $smpp = Net::SMPP->new_transceiver('smsc.foo.net', port=>2552) or die;
\&  $resp_pdu = $smpp->submit_sm(destination_addr => '447799658372',
\&                               data => 'test message') or die;
\&  ***
.Ve
.PP
Typical server, run from inetd:
.PP
.Vb 1
\&  ***
.Ve
.PP
See test.pl for good templates with all official parameters, but
beware that the actual parameter values are ficticious as is the flow
of the dialog.
.SH "MULTIPART MESSAGE"
.IX Header "MULTIPART MESSAGE"
Reportedly (Zeus Panchenko) multipart messages can be gotten to work with
.PP
.Vb 11
\&  while (length ($msgtext)) {
\&    if ($multimsg_maxparts) {
\&      @udh_ar = map { sprintf "%x", $_ } $origref, $multimsg_maxparts, $multimsg_curpart;
\&      $udh = pack("hhhhhh",0x05, 0x00, 0x03 , @udh_ar);
\&      $resp_pdu = $smpp->submit_sm(destination_addr => $phone,
\&                           ...
\&                           short_message => $udh . $msgtext,
\&                         );
\&      ...
\&    }
\&  }
.Ve
.PP
#4#cut
=head1 \s-1VERSION\s0 4.0 \s-1SUPPORT\s0
.PP
Net::SMPP was originally written for version 3.4 of \s-1SMPP\s0 protocol. I
have since then gotten specifications for an earlier protocol, the
version 4.0 (Logical, eh? (pun intended)). In my understanding the
relevant differences are as follows (n.b. (ok) marks difference
that has already been implemented):
.PP
1. A reserved (always 0x00000000) field in message
   header (v4 p. 21) (ok)
.PP
2. Connection can not be opened in transceiver mode (this
   module will not enforce this restriction) (ok)
.PP
3. Command versioning. Version 0x01 == V4 (v4 p. 22) (ok)
.PP
4. Support for extended facilities has to be requested
   during bind (ok)
.PP
5. bind_* PDUs have facilities_mask field (v4 p. 25) (ok)
.PP
6. bind_*_resp PDUs have facilities_mask field (v4 p. 27) (ok)
.PP
7. outbind lacks system \s-1ID\s0 field (v4 p.30, v3.4 p. 54) (ok)
.PP
8. submit_sm lacks service_type and adds
   message_class (v4 p. 34, v3.4 p. 59) (ok)
.PP
9. submit_sm: telematic_interworking == protocol_id (ok)
.PP
10. submit_sm: starting from number of destinations and
    destination address the message format is substantially
    different. Actually the message format is somewhat
    similar to v3.4 submit_multi. (ok)
.PP
11. submit_sm: validity period encoded as an integer
    relative offset (was absolute time as C string) (ok)
.PP
12. submit_sm: replace_if_present flag missing (ok)
.PP
13. submit_sm: sm_length field is 2 octets (was one) (ok)
.PP
14. submit_sm_resp is completely different, but actually
    equal to v3.4 submit_multi_resp (v4 p. 37,
    v3.4 pp. 67,75) (ok)
.PP
15. submit_sm vs submit_multi: lacks service_type,
    adds message_class (ok)
.PP
16. submit_sm vs submit_multi: number_of_dests increased
    from 1 byte to 4 (ok)
.PP
17. submit_sm vs submit_multi: esm_class lacking, adds
    messaging_mode and msg_reference (ok)
.PP
18. submit_sm vs submit_multi: telematic_interworking == protocol_id (ok)
.PP
19. submit_sm vs submit_multi: replace_if_present missing (ok)
.PP
20. submit_sm vs submit_multi: sm_length is 2 bytes (was one) (ok)
.PP
21. submit_sm vs submit_multi: lacks dest_flag and distribution_list_name (ok)
.PP
22. deliver_sm: lacks service_type (ok)
.PP
23. deliver_sm: lacks esm_class, adds msg_reference and message_class (ok)
.PP
24. deliver_sm: telematic_interworking == protocol_id (ok)
.PP
25. deliver_sm: priority_level == priority_flag (ok)
.PP
26. deliver_sm: submit_time_stamp == schedule_delivery_time (ok)
.PP
27. deliver_sm: lacks validity_period, registered_delivery,
    and replace_if_present_flag (ok)
.PP
28. deliver_sm: lacks sm_default_msg_id (ok)
.PP
29. deliver_sm: sm_length is now 2 bytes (was one) (ok)
.PP
30. deliver_sm_resp: lacks message_id (v3.4 has the field, but its unused) (ok)
.PP
31. New command: delivery_receipt (ok)
.PP
32. New response: delivery_receipt_resp (ok)
.PP
33. query_sm: dest_addr_* fields added (v4 p. 46, v3.4 p. 95) (ok)
.PP
34. query_sm_resp: error_code renamed to network_error_code
    and increased in size from one to 4 bytes (ok)
.PP
35. cancel_sm: service_type renamed to message_class, also
    type changed (ok)
.PP
36. replace_sm: added dest_addr_* fields (ok)
.PP
37. replace_sm: data type of validity_period changed (ok)
.PP
38. replace_sm: added data_coding field (ok)
.PP
39. replace_sm: sm_length field increased from one to two bytes (ok)
.PP
40. In v3.4 command code 0x0009 means bind_transceiver,
    in v4.0 this very same code means delivery_receipt (bummer) (ok)
.PP
41. In v3.4 enquire_link is 0x0015 where as in v4 it is 0x000a (ok)
.PP
To create version 4 connection, you must specify smpp_version => 0x40
and you should not bind as transceiver as that is not supported by the
specification.
.PP
As v3.4 specification seems more mature, I recommend that where attributes
have been renamed between v4 and v3.4 you stick to using v3.4 names. I
have tried to provide compatibility code whenever possible.
.PP
#4#end
.SH "MISC. NOTES"
.IX Header "MISC. NOTES"
Unless you wrote your program to be multithreaded or
multiprocess, everything will happen in one thread of execution.
Thus if you get unbind while doing something else (e.g. checking
your spool directory), it stays in operating system level buffers until
you actually call \fIread_pdu()\fR. Knowing about unbind or not is of little
use. You can write your program to assume the network traffic arrives
only exactly when you call \fIread_pdu()\fR.
.PP
Regarding the unbind, it is normally handled by a dispatch table
automatically if you use \fIwait_pdu()\fR to receive your traffic. But
if you created your own dispatch table, you will have to add it
there yourself. If you are calling \fIread_pdu()\fR then you have
to handle it yourslef. Even if you are using the
supplied table, you may want to double check \- there could be a bug.
.PP
One more thing: if your problem is knowing whether \fIwait_pdu()\fR or
\&\fIread_pdu()\fR would block, then you have two possible solutions:
.PP
.Vb 5
\&        1. use select(2) systemcall to determine for the socket
\&           is ready for reading
\&        2. structure your program as several processes (e.g. one
\&           for sending and one for receiving) so that you
\&           can afford to block
.Ve
.PP
The above two tricks are not specific to this module. Consult any standard
text book on \s-1TCP/IP\s0 network programming.
.SH "ERRORS"
.IX Header "ERRORS"
Please consult \f(CW\*(C`status_code\*(C'\fR table in the beginning of the source code or
\&\s-1SMPP\s0 specification section 5.1.3, table 5\-2, pp.112\-114.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "TESTS / WHAT IS KNOWN TO WORK"
.IX Header "TESTS / WHAT IS KNOWN TO WORK"
Interoperates with itself.
.SH "TO DO AND BUGS"
.IX Header "TO DO AND BUGS"
.IP "\fIread_pdu()\fR can block even if socket selects for reading." 4
.IX Item "read_pdu() can block even if socket selects for reading."
.PD 0
.IP "The submit_multi command has not been implemented." 4
.IX Item "The submit_multi command has not been implemented."
.PD
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Sampo Kellomaki <sampo@symlabs.com>
.PP
Net::SMPP is copyright (c) 2001\-2010 by Sampo Kellomaki, All rights reserved.
Portions copyright (c) 2001\-2005 by Symlabs, All rights reserved.
You may use and distribute Net::SMPP under same terms as perl itself.
.PP
\&\s-1NET::SMPP\s0 \s-1COMES\s0 \s-1WITH\s0 \s-1ABSOLUTELY\s0 \s-1NO\s0 \s-1WARRANTY\s0.
.SH "PLUG"
.IX Header "PLUG"
This work was sponsored by Symlabs, the \s-1LDAP\s0 and directory experts
(www.symlabs.com).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "test.pl from this package" 4
.IX Item "test.pl from this package"
.PD 0
.IP "Short Message Peer to Peer Protocol Specification v3.4, 12\-Oct\-1999, Issue 1.2" 4
.IX Item "Short Message Peer to Peer Protocol Specification v3.4, 12-Oct-1999, Issue 1.2"
.IP "www.etsi.fr" 4
.IX Item "www.etsi.fr"
.IP "\s-1GSM\s0 03.40, v5.7.1" 4
.IX Item "GSM 03.40, v5.7.1"
.IP "www.wapforum.org" 4
.IX Item "www.wapforum.org"
.IP "Short Message Peer to Peer (\s-1SMPP\s0) V4 Protocol Specification, 29\-Apr\-1997, Version 1.1 (from Aldiscon/Logica)  #4" 4
.IX Item "Short Message Peer to Peer (SMPP) V4 Protocol Specification, 29-Apr-1997, Version 1.1 (from Aldiscon/Logica)  #4"
.IP "http://www.hsl.uk.com/documents/advserv\-sms\-smpp.pdf" 4
.IX Item "http://www.hsl.uk.com/documents/advserv-sms-smpp.pdf"
.IP "http://www.mobilesms.com/developers.asp" 4
.IX Item "http://www.mobilesms.com/developers.asp"
.IP "http://opensmpp.logica.com" 4
.IX Item "http://opensmpp.logica.com"
.IP "www.smpp.org (it appears as of July 2007 domain squatters have taken over the site and it is no longer useful)" 4
.IX Item "www.smpp.org (it appears as of July 2007 domain squatters have taken over the site and it is no longer useful)"
.IP "http://www.smsforum.net/  \*(-- New place for info (as of 20081214). However, this page announces the death of itself as of July 27, 2007. Great. The \s-1SMS\s0 folks really do not want anyone to implement their protocols from specifications." 4
.IX Item "http://www.smsforum.net/   New place for info (as of 20081214). However, this page announces the death of itself as of July 27, 2007. Great. The SMS folks really do not want anyone to implement their protocols from specifications."
.ie n .IP """Short Message Peer to Peer Protocol Specification v5.0 19\-February\-2003"", http://www.csoft.co.uk/documents/smppv50.pdf (good as of 20081214)" 4
.el .IP "``Short Message Peer to Peer Protocol Specification v5.0 19\-February\-2003'', http://www.csoft.co.uk/documents/smppv50.pdf (good as of 20081214)" 4
.IX Item "Short Message Peer to Peer Protocol Specification v5.0 19-February-2003, http://www.csoft.co.uk/documents/smppv50.pdf (good as of 20081214)"
.IP "http://freshmeat.net/projects/netsmpp/ (announcements about Net::SMPP)" 4
.IX Item "http://freshmeat.net/projects/netsmpp/ (announcements about Net::SMPP)"
.IP "http://zxid.org/smpp/net\-smpp.html (home page)" 4
.IX Item "http://zxid.org/smpp/net-smpp.html (home page)"
.IP "http://cpan.org/modules/by\-module/Net/Net\-SMPP\-1.12.tar.gz (download from \s-1CPAN\s0)" 4
.IX Item "http://cpan.org/modules/by-module/Net/Net-SMPP-1.12.tar.gz (download from CPAN)"
.IP "\fIperl\fR\|(1)" 4
.IX Item "perl"
